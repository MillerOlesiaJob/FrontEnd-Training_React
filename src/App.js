import React, {useEffect, useState} from 'react';
import Categories from "./components/Caregories/Categories";
import Question from "./components/Question/Question";
import Button from "./components/Button/Button";
import Popup from "./components/Popup/Popup";
import './App.css';

const dataBase = [
  //JS
  //Обработка событий
  //Циклы
  //DOM
  {
    category: 'javascript',
    questions: [
      {
        title: 'DOM',
        text: 'Какие параменты принимает insertAdjacentHTML',
        answer: [
          'position',
          'text',
        ]
      },
      {
        title: 'DOM',
        text: 'Назовите значения параметра <i>position</i> у insertAdjacentHTML',
        answer: [
          'beforebegin: до самого element (до открывающего тега)',
          'afterbegin: сразу после открывающего тега  element (перед первым потомком)',
          'beforeend: сразу перед закрывающим тегом element (после последнего потомка)',
          'afterend: после element (после закрывающего тега)',
        ]
      },
      {
        title: 'DOM',
        text: 'Какие опционные свойства есть у метода addEventListener?',
        answer: [
          'once: если true, тогда обработчик будет автоматически удалён после выполнения',
          'capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение.',
          'passive: если true, то указывает, что обработчик никогда не вызовет preventDefault()',
        ]
      },
      {
        title: 'Циклы',
        text: 'Для его используются циклы?',
        answer: [
          'Побочные эффекты',
          'Трансформация',
          'Фильтры',
          'Комбинирование элементов',
          'и т. д.',
        ],
        links: [
          'https://webdevblog.ru/vvedenie-v-funkcionalnoe-programmirovanie-na-javascript/',
        ]
      },
      //Объекты
      {
        title: 'Объекты',
        text: 'Как можно ограничить возможность изменения объекта?',
        answer: 'Object.freeze()',
        links: [],
      },
      //Замыкание
      {
        title: 'Замыкание',
        text: 'Что такое замыание?',
        answer: [
          'Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание дает вам доступ к Scope внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при созданиии функции, во время ее создания.',
          'Простыми словами: Замыкание - это функция внутри другой функции',
        ],
        links: [
          'https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures#:~:text=%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%86%D0%B8%D1%8F%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20%D0%B8,%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%2C%20%D0%B2%D0%BE%20%D0%B2%D1%80%D0%B5%D0%BC%D1%8F%20%D0%B5%D0%B5%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.',
        ],
      },
      //Асинхронность
      {
        title: 'Асинхронность',
        text: 'Что такое SetTimeout?',
        answer: 'Функция браузера (браузерный API). Не входит в спецификацию JS. Вызывается у глобального объекта window. Принимает два парамента: функцию и время, через которое вызовится эта функция в милисекундах',
        links: [
          '',
        ],
      },
      {
        title: 'Асинхронность',
        text: 'Что такое Main Thread?',
        answer:
          'Main Thread — это основной поток, где браузер выполняет JS, делает перерисовки, обрабатывает пользовательские действия и многое другое.' +
          'По сути, это то место, где движок JS интегрирован в браузер.',
        links: ['https://habr.com/ru/post/461401/'],
      },
      {
        title: 'Асинхронность',
        text: 'Что такое EventLoop?',
        answer: 'Поток выполнения задач в браузере',
        links: ['https://learn.javascript.ru/event-loop'],
      },
      {
        title: 'Асинхронность',
        text: 'Как работает EventLoop',
        answer:
          'Когда интерпретатор проходит по коду и натыкается на асинхронную операцию, он закидывает ее в браузерный сторонний API,' +
          'где она ждет указаное количество времени (есть мы говорим про SetTimeout)' +
          '/ вызова (если это слушатели событий)' +
          '/ выполение остальных операций интерпретатором (пример Promise).' +
          'После операция попадает в очередь событий (Callback Queue).' +
          'Как только интерпретатор выполнит все указаные действия в коде, события из очереди событий по очереди попадают в call stack',
        links: [''],
      },
      {
        title: 'Асинхронность',
        text: 'Что такое Promise?',
        answer:
          'Promise – это специальный объект, который содержит своё состояние.' +
          'Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).',
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Что такое Промисификация?',
        answer: 'Промисификация – это когда берут асинхронную функциональность и делают для неё обёртку, возвращающую промис.',
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Какую проблему решает Promise?',
        answer: 'Просимы были введены для избежания CallbackHellа, который подразумевал под собой создания большого количества вложеностей,' +
          'что приводило к усложнению читабельности кода и трудностям в поддержании данного кода',
        links: [''],
      },
      {
        title: 'Асинхронность',
        text: 'Назвать внутренние свойства объекта new Promise()?',
        answer: [
          'PromiseState – состояние, вначале «pending».',
          'PromiseResult – результат, при создании значения нет.',
          'PromiseFulfillReactions – список функций-обработчиков успешного выполнения.',
          'PromiseRejectReactions – список функций-обработчиков ошибки.'
        ],
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Назвать методы для навешивания обработчиков в Promise',
        answer: [
          'then - навешивает обработчики на успешный результат или ошибку есть была вызвана функция resolve / reject',
          'catch – используется для отлавливания ошибок',
          'finally – выполняется независимо от успеха или ошибки при выполения промиса',
        ],
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Назвать статические методы Promise',
        answer: [
          'Promise.all(iterable) - Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис,' +
          'который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.',
          'Promise.race(iterable) – получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.' +
          'Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.',
          'Promise.resolve(value) – Вызов Promise.resolve(value) создаёт успешно выполнившийся промис с результатом value.',
          'Promise.reject(error) – Вызов Promise.reject(error) создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой error.',
        ],
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Что такое fetch?',
        answer:
          'Fetch - новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. Он гораздо мощнее, чем httpGet.' +
          'Этот метод использует промисы.',
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Что такое Чейнинг?',
        answer:
          '«Чейнинг» (chaining) - возможность строить асинхронные цепочки из промисов – пожалуй,' +
          'основная причина, из-за которой существуют и активно используются промисы.' +
          'Используется для передачи результата от одного обработчика к другому',
        links: ['https://learn.javascript.ru/promise'],
      },
      {
        title: 'Асинхронность',
        text: 'Как работает Async Await?',
        answer:
          'Cпециальный синтаксис для работы с промисами. По сути, это - синтаксический сахар, который позволяет более комфортно работать с промисами. ' +
          'Начнём с ключевого слова async. Оно ставится перед функцией.' +
          'У слова async один простой смысл: эта функция всегда возвращает промис.' +
          'Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится.' +
          'После чего оно вернёт его результат, и выполнение кода продолжится.' +
          'Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку.' +
          'Результат выполнения промиса справа от await можно записать в переменную',
        links: ['https://learn.javascript.ru/async-await'],
      },
      // Запросы на сервер
      {
        title: 'Асинхронность. Запросы на сервер',
        text: 'Назовите способы создания запросов на сервер',
        answer: ['XHR (XMLHttpRequest)', 'fetch'],
        links: [''],
      },
      {
        title: 'Асинхронность. Запросы на сервер',
        text: 'Что такое AJAX?',
        answer:
          'Ajax означает Асинхронный JavaScript и XML. В основе технологии лежит использование нестандартного объекта XMLHttpRequest,' +
          'необходимого для взаимодействия со скриптами на стороне сервера. Объект может как отправлять, так и получать информацию в различных форматах' +
          'включая XML, HTML и даже текстовые файлы. Самое привлекательное в Ajax — это его асинхронный принцип работы.' +
          'С помощью этой технологии можно осуществлять взаимодействие с сервером без необходимости перезагрузки страницы.' +
          'Это позволяет обновлять содержимое страницы частично, в зависимости от действий пользователя.',
        links: ['https://developer.mozilla.org/ru/docs/Web/Guide/AJAX/%D0%A1_%D1%87%D0%B5%D0%B3%D0%BE_%D0%BD%D0%B0%D1%87%D0%B0%D1%82%D1%8C'],
      },
      {
        title: 'Асинхронность. Запросы на сервер',
        text: 'Как работать с XHR?',
        answer: [
          'const xhr = new XMLHttpRequest()',
          'xhr.open(метод, url)',
          'xhr.responseType = "js"',
          'xhr.setRequestHeader(name, value) - для POST запросов',
          'xhr.onload = () => xhr.response (можно работать с результатами запроса)',
          'xhr.onerror = () => xhr.response (действия при ошибке)',
          'xhr.send() - при GET запросах',
          'xhr.send(JSON.stringify(body)) - при POST запросах, body - информация для создания данных'
        ],
        links: [''],
      },
      {
        title: 'Асинхронность. Запросы на сервер',
        text: 'Как работать с fetch?',
        answer: [
          'GET:',
          'fetch(url) -  по умолчания выполняется метод GET',
          ' .then(response => response.json())',
          ' ',
          'POST:',
          'fetch(url, {method, body = {}, headers = {name: value}})',
        ],
        links: [''],
      },
      {
        title: 'Асинхронность. Запросы на сервер',
        text: 'Назвать методы XHR запросов',
        answer: [
          'get() - получение данных',
          'post() - для создания данных',
          'delete() - для удаления данных',
          'put() - для полного обновления элемента',
          'patch() - для частичного обновления элемента'
        ],
        links: [''],
      },
      //Функциональное программирование
      {
        title: 'Функционалльное программирование',
        text: 'Что такое композиция функций?',
        answer: 'Композиция это техника, позволяющая вам взять две или больше простых функций и объединить их в одну, более сложную функцию, выполняющую подфункции в логическом порядке с любыми данными',
        links: [
          'http://prgssr.ru/development/kompoziciya-funkcij.html',
        ],
      },
      {
        title: 'Функционалльное программирование',
        text: 'Что такое каррирование?',
        answer: 'Каррирование – это процесс получения функции, которая принимает n аргументов, и превращения ее в n функций, каждая из которых принимает один аргумент.',
        links: [],
      },
      {
        title: 'Функциональное программирование',
        text: 'Дать определение функции высшего порядка',
        answer: '<b>Функция высшего порядка</b> - это функция, которая возвращает функцию или принимает другую функцию в качестве параметра. Самым явным примером функции высшего порядка является <b>addEventListener</b>',
        links: [
          'https://habr.com/ru/post/154105/'
        ]
      },
      {
        title: 'Функциональное программирование',
        text: 'Назовите примеры побочных эффектов',
        answer: [
          'Видоизменение входных параметров',
          'console.log',
          'HTTP вызовы (AJAX/fetch)',
          'Изменение в файловой системе',
          'Запросы DOM',
        ],
        links: [
          'https://habr.com/ru/post/437512/'
        ]
      },
      {
        title: 'Функциональное программирование',
        text: 'Что такое чистая функция?',
        answer: 'Чистая функция - "строительный блок" функционального програмирования, которая каждый раз возвращает одинаковый результат, когда она вызывается с тем же набором аргументов и не вызывает побочных эффектов. Из преимуществ можно выделить простоту в понимании и тестировании.',
        links: [
          'https://habr.com/ru/post/437512/'
        ]
      },
      {
        title: 'Функциональное программирование',
        text: 'Назвать принципы функционального программирования',
        answer: [
          'Использование чистых функций',
          'Копирование, а не переопределение переменных',
          'Для объявления переменных использовать только CONST'
        ],
        links: [
          'https://habr.com/ru/post/154105/',
          'https://webdevblog.ru/vvedenie-v-funkcionalnoe-programmirovanie-na-javascript/',
        ]
      },
      //Методы массивов
      {
        title: 'Методы массивов',
        text: 'Назвать известные методы массивов',
        answer: '',
        links: [
          'https://habr.com/ru/company/ruvds/blog/413169/',
        ]
      },
      //Контект
      {
        title: 'Контект',
        text: 'Что такое контекст?',
        answer: 'Контекст выполнения функции — это одно из фундаментальных понятий в JavaScript. Контекстом еще часто называют значение переменной this внутри функции',
        links: ['https://proweb63.ru/help/js/kontekst-vyipolneniya-funkczii-v-javascript#:~:text=%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%BE%D0%B4%D0%BD%D0%BE,%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9%20this%20%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8.&text=%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D1%82%20%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%20%D0%BA,%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D1%83%D0%BD%D0%B8%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9%20%D0%B4%D0%BB%D1%8F%20%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%B3%D0%BE%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0.'],
      },
      {
        title: 'Контект',
        text: 'Назвать методы работы с контектстом',
        answer: 'BIND, CALL, APPLY',
        links: [''],
      },
      {
        title: 'Контект',
        text: 'Какая разница между BIND, CALL, APPLY',
        answer: [
          'BIND - привязывает контект, но не вызывает функцию',
          'CALL - привязывает контект и сразу вызывает функцию с этим контекстом',
          'APPLY - требует указания двух параментов(контект и параменты для новосозданой функции) и сразу вызывает функцию'],
        links: [''],
      },
      // ООП
      {
        title: 'Принципы ООП',
        text: 'Назвать принципы ООП',
        answer: [
          'Абстракция',
          'Инкапсуляция',
          'Наследование',
          'Полиморфизм'
        ],
      },
      {
        title: 'Принципы ООП',
        text: 'Объяснить принцип Инкапсуляции',
        answer: 'Инкапсуляция — это контроль доступа к полям и методам объекта. Под контролем доступа подразумевается не только можно/неможно, но и различные валидации, подгрузки, вычисления и прочее динамическое поведение.',
        links: ['https://habr.com/ru/post/463125/'],
      },
      {
        title: 'Принципы ООП',
        text: 'Объяснить принцип Наследования',
        answer: 'Наследование — это механизм системы, который позволяет, как бы парадоксально это не звучало, наследовать одними классами свойства и поведение других классов для дальнейшего расширения или модификации',
        links: ['https://habr.com/ru/post/463125/'],
      },
      {
        title: 'Принципы ООП',
        text: 'Объяснить принцип Полиморфизма',
        answer: 'Полиморфизм — способность метода работать с разными данным. При работе с одним и тем же методом (функцией) разные сущности по-разному могут его использовать. Возможность применения в данном контексте свойств и методов, но внутри эти методы меняются для каждой сущности. Реализация задач одной и той же идеи разными способами',
        links: ['https://habr.com/ru/post/463125/'],
      },
      {
        title: 'Принципы ООП',
        text: 'Объяснить принцип Абстракции',
        answer: 'Абстракция – построение (разработка) модели, оставляем только важные параметры (свойства, методы). (На этапе разработки документации кода это особенно важно).',
        links: ['https://habr.com/ru/post/463125/'],
      },
      {
        title: 'ООП',
        text: 'Объяснить, что такое ООП',
        answer: 'Объектно-ориентированное программирование (в дальнейшем ООП) — парадигма программирования, в которой основными концепциями являются понятия объектов и классов.В центре ООП находится понятие объекта.',
        links: [
          'https://devcolibri.com/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BE%D0%BE%D0%BF-%D0%B8-%D1%81-%D1%87%D0%B5%D0%BC-%D0%B5%D0%B3%D0%BE-%D0%B5%D0%B4%D1%8F%D1%82/',
          'https://habr.com/ru/post/463125/',
        ]
      },
    ],
  },
  //Паттерны програмирования
  //Функции
  //Классы
  //Прототипы
  //СSS
  {
    category: 'css',
    questions: [
      {
        title: 'Блочная модель',
        text: 'Что под собой подразумевает блочная модель?',
        answer: 'Блочная модель CSS — одна из основ веб-дизайна, которая в дальнейшем помогает лучше кастомизировать страницы. В соответствии с концепцией блочной модели, каждый элемент на странице представляет собой прямоугольный блок и может иметь ширину, высоту, поля, границы и отступы. Это стоит повторить: Каждый элемент на странице представляет собой прямоугольный блок.',
        links: [
          'https://html5book.ru/css-blochnaya-model/',
          'https://developer.mozilla.org/ru/docs/Web/CSS/box_model',
          'https://webref.ru/layout/learn-html-css/box-model'
        ]
      },
      {
        title: 'Вес селекторов',
        text: 'Назвать, чему равен вес селокторов',
        answer: [
          {
            value: '1',
            explan: 'селектор тега'
          },
          {
            value: '10',
            explan: 'Селектор класса'
          },
          {
            value: '100',
            explan: 'Серектор id'
          },
          {
            value: '10',
            explan: 'Селектор аттрибута'
          },
          {
            value: '1000',
            explan: 'Inline стили'
          }
        ],
      },
      {
        title: 'Селекторы',
        text: 'Назвать, какие селекторы существуют',
        answer: [
          '*all',
          '#id',
          '.class',
          'контекстный селектор (X Y - стили применятся только к Y, которые ВНУТРИ X)', 'селектор тега (X)',
          'псевдоклассы',
          'асевдоэлементы',
          'соседний селектор (X + Y - стили применятся только к тем Y, которые следуют СРАЗУ за X)',
          'прямой потомок (X > Y - стили применятся только к тем Y, которые являются первоуровневыми потомками X)',
          'менее строкий Соседний селектор (X ~ Y - выберит ВСЕ Y, которые следуют за X)',
          'селектор аттрибута (можно указать точное значение аттрибота, например ссылку или только часть через a[href*=`linkPart`], можно указать ^ - начало строки и $ - конец строки)',
        ],
        links: ['https://code.tutsplus.com/ru/tutorials/the-30-css-explans-you-must-memorize--net-16048']
      },
      {
        title: 'Псевдоелементы',
        text: 'Назвать известные псевдоэлементы',
        answer: [
          {
            value: 'p::first-line',
            explan: 'Выберем первую строку параграфа'
          },
          {
            value: 'p::first-letter',
            explan: 'Выберем первую букву параграфа'
          },
          {
            value: '',
            explan: ''
          }
        ],
        links: [],
      },
      {
        title: 'Псевдоклассы',
        text: 'Назвать известные псевдоклассы',
        answer: [
          {
            value: 'X:first-of-type',
            explan: 'Выбирает первого наследника указанного типа'
          },
          {
            value: 'X:only-of-type',
            explan: 'Выберет дочерний элемент, только если он единственный у родителя.'
          },
          {
            value: 'X:only-child',
            explan: 'позволяет выбрать элемент, являющийся единственным наследником своего родителя',
            example: '../images/only-child.jpg',
          },
          {
            value: 'X:last-child',
            explan: 'Выберет последний дочерний элемент.',
          },
          {
            value: 'first-child',
            explan: 'Выберет только первый дочерний элемент.',
          },
          {
            value: 'X:nth-last-of-type(n)',
            explan: 'Выберет тоько последний элемент указанного типа',
          },
          {
            value: 'X:nth-of-type(n)',
            explan: 'Выберет элемент указанного типа по номеру',
          },
          {
            value: 'X:nth-last-child(n)',
            explan: 'Выберет дочерний элемент с конца',
          },
          {
            value: 'X:nth-child(n)',
            explan: 'Выберет дочерний элемент по указаному порядковому номеру',
          },
          {
            value: 'X:not(explan)',
            explan: 'Отрицание',
          },
          {
            value: 'X:hover',
            explan: 'Псевдокласс пользовательского действия',
          },
          {
            value: 'X:after',
            explan: 'Позволяют сгенерировать контент после указанного элемента.',
          },
          {
            value: 'X:before',
            explan: 'Позволяют сгенерировать контент перед указанным элементом.',
          },
          {
            value: 'X:checked',
            explan: 'Выберет только отмеченные элементы пользовательского интерфейса.',
          },
          {
            value: 'X:link',
            explan: 'Для стилизации ссылок, на которые пользователь ещё не нажимал.',
          },
          {
            value: 'X:visited',
            explan: 'Для стилизации только тех ссылок, на которые пользователь нажал.',
          }
        ],
      },
      {
        title: 'Анимация CSS',
        text: 'Как создавать анимацию?',
        answer: [
          'CSS transitions - позволяют сделать изменения CSS-свойств плавно и в течение некоторого времени.',
          'CSS animations - позволяют делать более сложные анимации, нежели CSS transitions. Весь секрет в @keyframes.' +
          'Правило @keyframes позволяет создавать анимацию с помощью набора ключевых кадров,' +
          'то есть описывает состояние объекта в определенный момент времени.',
          'Motion Path Module CSS - позволяет создавать движение объектов по контуру через специальное свойство motion-path.' +
          'Раньше такую анимацию можно было сделать только с помощью SVG или сложных скриптов.'
        ],
        links: ['https://stfalcon.com/ru/blog/post/animation-css']
      },
      {
        title: 'Анимация CSS',
        text: 'Назвать свойства для работы с Motion Path Module CSS?',
        answer: [
          'motion-path — это свойство позволяет указать точки(координаты) по которым будет двигаться объект. Синтаксис такой же как у SVG-атрибута path.',
          'motion-offset — это свойство приводит объект в движение от начальной точки до конечной.',
          'motion-rotation — это свойство позволяет указать, какой стороной вперед будет двигаться объект.'
        ],
        links: ['https://stfalcon.com/ru/blog/post/animation-css']
      },
      {
        title: 'Анимация CSS',
        text: 'Назвать свойства для работы с CSS animations?',
        answer: [
          'animation-iteration-count — задаёт количество повторов анимации, значение по умолчанию 1.' +
          'Значение infinite означает, что анимация будет проигрываться бесконечно.',
          'animation-direction — задаёт направление анимации.',
          'animation-play-state — данное свойство управляет остановкой и прогрыванием анимации.' +
          'Есть два значения, running (анимация проигрывается, по умолчанию) и paused (останавливает анимацию).',
          'animation-fill-mode — устанавливает, какие CSS-свойства будут приминены к объекту до или после анимации',
          'animation-duration — задаёт значение продолжительности анимации, время можно указывать в секундах или миллисекундах.',
          'animation-timing-function — временная функция, указывает точки ускорения и замедления за определенный период времени' +
          'для контроля изменения скорости анимации.',
          'animation-delay — задаёт задержку времени до начала анимации, можно указывать в секундах или миллисекундах.',
        ],
        links: ['https://stfalcon.com/ru/blog/post/animation-css']
      },
      {
        title: 'Анимация CSS',
        text: 'Назвать свойства для работы с CSS transitions?',
        answer: [
          'transition-property — указывает список свойств, которые будут анимироваться',
          'transition-duration — задаёт значение продолжительности анимации, время можно указывать в секундах или миллисекундах.',
          'transition-timing-function — временная функция, указывает точки ускорения и замедления за определенный период времени' +
          'для контроля изменения скорости анимации.',
          'transition-delay — задаёт задержку времени до начала анимации, можно указывать в секундах или миллисекундах.',
          'transition — это общее свойство, которое позволяет перечислить первые четыре свойства в порядке: property, duration, timing-function, delay.'
        ],
        links: ['https://stfalcon.com/ru/blog/post/animation-css']
      },
    ],
  },
  //HTML
  {
    category: 'html',
    questions: [
      {
        title: 'HTML5. Семантическая верстка',
        text:'Назвать известные семантические теги',
        answer: [
          '<article> <b>article</b></b> - отпределяет независимый, самодостаточный контент',
          '<aside> <b> aside</b> -  определяет некий контент, находящийся в стороне от контента, внутри которого он расположен (как боковой блок страницы, "сайдбар")',
          '<figcaption> <b>figcaption</b> - добавление визуального пояснения к изображению.',
          '<figure> <b>figure</b> - используется для группирования различных самодостаточных элементов</b> - иллюстраций, диаграмм, фотографий, листингов кода и т.д',
          '<footer> <b>footer</b> - определение "подвала" документа или раздела',
          '<header> <b>header</b> - определение заголовочной части документа или раздела ("шапки")',
          '<main> <b>main</b> - определяет основной контент документа. На стронице может быть только один',
          '<mark> <b>mark</b> - определяет маркированный/подсвеченный текст',
          '<nav> <b>nav</b> - определяет набор ссылок навигации. Предназначен только для основного влока навигационных ссылок',
          '<section> <b>section</b> - определяет раздел в документе',
          '<time> <b>time</b> - определяет дату/время',
          '<summary> <b>summary</b> - определяет видимый заголовок элемента <details>',
          '<details> <b>details</b> - определяет дополнительную информацию, которую пользователь может открывать или закрывать',
        ],
        links: [
          'https://msiter.ru/tutorials/html5/semantic_elements'
        ]
      },
    ]
  },
  //REACT
  //события
  {
  category: 'REACT',
    questions: [
      {
        title: 'События в REACT компоненте',
        text: 'Как предотвратить слишком быстрый или слишком частый вызов функции?',
        answer: [
          'троттлинг: выборочные изменения, зависимые от частоты, основанной на времени (напр. _.throttle)',
          'дебаунсинг: изменения, задействованные после некого периода бездействия (напр. _.debounce)',
          'троттлинг с помощью requestAnimationFrame: выборочные изменения, основанные на requestAnimationFrame (напр. raf-schd)',
        ],
        links: [
          'https://ru.reactjs.org/docs/faq-functions.html'
        ]
      },
    ]
  }
];

function App() {
  const [categories, setCategories] = useState([]);
  console.log(categories)
  const [isStartClicked, setStartClicked] = useState(false);
  const [isQuestionsOver, setQuestionsOver] = useState(false);
  const [isShowPopup, setShowPopup] = useState(false);
  const [isNewCategories, setNewCategories] = useState(false);

  const handleCheckItem = (newCategory) => {
    console.log('newCategory ', newCategory)
    setCategories((prevCategories) => ([
      ...prevCategories,
      newCategory,
    ]));
  };

  const handleUncheckItem = (unnecessarCategory) => {
    setCategories((prevCategories) => ([
      ...prevCategories.filter(category => category !== unnecessarCategory)
    ]));
  };

  const startLearning = () => {
    setStartClicked(true);
  };

  const againLearning = () => {
    setShowPopup(true);
  };

  const getQuestions = () => {
    let array = [];
     categories.forEach(category => {
      dataBase.forEach(questionsCategory => {
        if (questionsCategory.category === category) {
          array = array.concat(questionsCategory.questions);
        }
      });
    });
     return array;
  };

  return (
    <div className="main-container">
      <Categories
        handleCheckItem={handleCheckItem}
        handleUncheckItem={handleUncheckItem}
        isNewCategories={isNewCategories}
      />
      {isQuestionsOver && <p className='title__warning'>ВЫ ОТВЕТИЛИ НА ВСЕ ВОПРОСЫ</p>}
      <Button
        onClick={isQuestionsOver ? againLearning : startLearning}
        title={isQuestionsOver ? 'TRAIN AGAIN' : 'START'}
        //TODO add class for unable button
        className='button button--start'
      />
      {isStartClicked &&
        <Question questions={getQuestions()} setQuestionsOver={setQuestionsOver}/>
      }
      {isShowPopup &&
      <Popup setShowPopup={setShowPopup} setNewCategories={setNewCategories}/>}
    </div>
  );
}

export default App;
